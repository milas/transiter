// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: vehicle_queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jamespfennell/transiter/db/types"
)

const deleteVehicles = `-- name: DeleteVehicles :exec
DELETE FROM vehicle
WHERE system_pk = $1
  AND (feed_pk = $2
       OR vehicle.id = ANY($3::text[])
       OR trip_pk = ANY($4::bigint[]))
`

type DeleteVehiclesParams struct {
	SystemPk   int64
	FeedPk     int64
	VehicleIds []string
	TripPks    []int64
}

func (q *Queries) DeleteVehicles(ctx context.Context, arg DeleteVehiclesParams) error {
	_, err := q.db.Exec(ctx, deleteVehicles,
		arg.SystemPk,
		arg.FeedPk,
		arg.VehicleIds,
		arg.TripPks,
	)
	return err
}

const getVehicle = `-- name: GetVehicle :one
SELECT vehicle.pk, vehicle.id, vehicle.system_pk, vehicle.trip_pk, vehicle.label, vehicle.license_plate, vehicle.current_status, vehicle.bearing, vehicle.odometer, vehicle.speed, vehicle.congestion_level, vehicle.updated_at, vehicle.current_stop_pk, vehicle.current_stop_sequence, vehicle.occupancy_status, vehicle.feed_pk, vehicle.occupancy_percentage, vehicle.location,
       stop.id as stop_id,
       stop.name as stop_name,
       trip.id as trip_id,
       trip.direction_id as trip_direction_id,
       route.id as route_id,
       route.color as route_color
FROM vehicle
LEFT JOIN stop ON vehicle.current_stop_pk = stop.pk
LEFT JOIN trip ON vehicle.trip_pk = trip.pk
LEFT JOIN route ON trip.route_pk = route.pk
WHERE vehicle.system_pk = $1 AND vehicle.id = $2
`

type GetVehicleParams struct {
	SystemPk  int64
	VehicleID pgtype.Text
}

type GetVehicleRow struct {
	Pk                  int64
	ID                  pgtype.Text
	SystemPk            int64
	TripPk              pgtype.Int8
	Label               pgtype.Text
	LicensePlate        pgtype.Text
	CurrentStatus       pgtype.Text
	Bearing             pgtype.Float4
	Odometer            pgtype.Float8
	Speed               pgtype.Float4
	CongestionLevel     string
	UpdatedAt           pgtype.Timestamptz
	CurrentStopPk       pgtype.Int8
	CurrentStopSequence pgtype.Int4
	OccupancyStatus     pgtype.Text
	FeedPk              int64
	OccupancyPercentage pgtype.Int4
	Location            types.Geography
	StopID              pgtype.Text
	StopName            pgtype.Text
	TripID              pgtype.Text
	TripDirectionID     pgtype.Bool
	RouteID             pgtype.Text
	RouteColor          pgtype.Text
}

func (q *Queries) GetVehicle(ctx context.Context, arg GetVehicleParams) (GetVehicleRow, error) {
	row := q.db.QueryRow(ctx, getVehicle, arg.SystemPk, arg.VehicleID)
	var i GetVehicleRow
	err := row.Scan(
		&i.Pk,
		&i.ID,
		&i.SystemPk,
		&i.TripPk,
		&i.Label,
		&i.LicensePlate,
		&i.CurrentStatus,
		&i.Bearing,
		&i.Odometer,
		&i.Speed,
		&i.CongestionLevel,
		&i.UpdatedAt,
		&i.CurrentStopPk,
		&i.CurrentStopSequence,
		&i.OccupancyStatus,
		&i.FeedPk,
		&i.OccupancyPercentage,
		&i.Location,
		&i.StopID,
		&i.StopName,
		&i.TripID,
		&i.TripDirectionID,
		&i.RouteID,
		&i.RouteColor,
	)
	return i, err
}

const insertVehicle = `-- name: InsertVehicle :exec
INSERT INTO vehicle
    (id, system_pk, trip_pk, label, license_plate, current_status, location, bearing, odometer, speed, congestion_level, updated_at, current_stop_pk, current_stop_sequence, occupancy_status, feed_pk, occupancy_percentage)
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
`

type InsertVehicleParams struct {
	ID                  pgtype.Text
	SystemPk            int64
	TripPk              pgtype.Int8
	Label               pgtype.Text
	LicensePlate        pgtype.Text
	CurrentStatus       pgtype.Text
	Location            types.Geography
	Bearing             pgtype.Float4
	Odometer            pgtype.Float8
	Speed               pgtype.Float4
	CongestionLevel     string
	UpdatedAt           pgtype.Timestamptz
	CurrentStopPk       pgtype.Int8
	CurrentStopSequence pgtype.Int4
	OccupancyStatus     pgtype.Text
	FeedPk              int64
	OccupancyPercentage pgtype.Int4
}

func (q *Queries) InsertVehicle(ctx context.Context, arg InsertVehicleParams) error {
	_, err := q.db.Exec(ctx, insertVehicle,
		arg.ID,
		arg.SystemPk,
		arg.TripPk,
		arg.Label,
		arg.LicensePlate,
		arg.CurrentStatus,
		arg.Location,
		arg.Bearing,
		arg.Odometer,
		arg.Speed,
		arg.CongestionLevel,
		arg.UpdatedAt,
		arg.CurrentStopPk,
		arg.CurrentStopSequence,
		arg.OccupancyStatus,
		arg.FeedPk,
		arg.OccupancyPercentage,
	)
	return err
}

const listVehicles = `-- name: ListVehicles :many
SELECT vehicle.pk, vehicle.id, vehicle.system_pk, vehicle.trip_pk, vehicle.label, vehicle.license_plate, vehicle.current_status, vehicle.bearing, vehicle.odometer, vehicle.speed, vehicle.congestion_level, vehicle.updated_at, vehicle.current_stop_pk, vehicle.current_stop_sequence, vehicle.occupancy_status, vehicle.feed_pk, vehicle.occupancy_percentage, vehicle.location,
       stop.id as stop_id,
       stop.name as stop_name,
       trip.id as trip_id,
       trip.direction_id as trip_direction_id,
       route.id as route_id,
       route.color as route_color
FROM vehicle
LEFT JOIN stop ON vehicle.current_stop_pk = stop.pk
LEFT JOIN trip ON vehicle.trip_pk = trip.pk
LEFT JOIN route ON trip.route_pk = route.pk
WHERE vehicle.system_pk = $1
  AND vehicle.id >= $2
  AND (
    NOT $3::bool OR
    vehicle.id = ANY($4::text[])
  )
ORDER BY vehicle.id
LIMIT $5
`

type ListVehiclesParams struct {
	SystemPk       int64
	FirstVehicleID pgtype.Text
	FilterByID     bool
	VehicleIds     []string
	NumVehicles    int32
}

type ListVehiclesRow struct {
	Pk                  int64
	ID                  pgtype.Text
	SystemPk            int64
	TripPk              pgtype.Int8
	Label               pgtype.Text
	LicensePlate        pgtype.Text
	CurrentStatus       pgtype.Text
	Bearing             pgtype.Float4
	Odometer            pgtype.Float8
	Speed               pgtype.Float4
	CongestionLevel     string
	UpdatedAt           pgtype.Timestamptz
	CurrentStopPk       pgtype.Int8
	CurrentStopSequence pgtype.Int4
	OccupancyStatus     pgtype.Text
	FeedPk              int64
	OccupancyPercentage pgtype.Int4
	Location            types.Geography
	StopID              pgtype.Text
	StopName            pgtype.Text
	TripID              pgtype.Text
	TripDirectionID     pgtype.Bool
	RouteID             pgtype.Text
	RouteColor          pgtype.Text
}

func (q *Queries) ListVehicles(ctx context.Context, arg ListVehiclesParams) ([]ListVehiclesRow, error) {
	rows, err := q.db.Query(ctx, listVehicles,
		arg.SystemPk,
		arg.FirstVehicleID,
		arg.FilterByID,
		arg.VehicleIds,
		arg.NumVehicles,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVehiclesRow
	for rows.Next() {
		var i ListVehiclesRow
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.SystemPk,
			&i.TripPk,
			&i.Label,
			&i.LicensePlate,
			&i.CurrentStatus,
			&i.Bearing,
			&i.Odometer,
			&i.Speed,
			&i.CongestionLevel,
			&i.UpdatedAt,
			&i.CurrentStopPk,
			&i.CurrentStopSequence,
			&i.OccupancyStatus,
			&i.FeedPk,
			&i.OccupancyPercentage,
			&i.Location,
			&i.StopID,
			&i.StopName,
			&i.TripID,
			&i.TripDirectionID,
			&i.RouteID,
			&i.RouteColor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listVehicles_Geographic = `-- name: ListVehicles_Geographic :many
WITH distance AS (
    SELECT
        vehicle.pk vehicle_pk,
        vehicle.location <-> $3::geography distance
    FROM vehicle
    WHERE vehicle.location IS NOT NULL
    AND vehicle.system_pk = $4
)
SELECT vehicle.pk, vehicle.id, vehicle.system_pk, vehicle.trip_pk, vehicle.label, vehicle.license_plate, vehicle.current_status, vehicle.bearing, vehicle.odometer, vehicle.speed, vehicle.congestion_level, vehicle.updated_at, vehicle.current_stop_pk, vehicle.current_stop_sequence, vehicle.occupancy_status, vehicle.feed_pk, vehicle.occupancy_percentage, vehicle.location,
       stop.id as stop_id,
       stop.name as stop_name,
       trip.id as trip_id,
       trip.direction_id as trip_direction_id,
       route.id as route_id,
       route.color as route_color
FROM vehicle
INNER JOIN distance ON vehicle.pk = distance.vehicle_pk
AND distance.distance <= 1000 * $1::float
LEFT JOIN stop ON vehicle.current_stop_pk = stop.pk
LEFT JOIN trip ON vehicle.trip_pk = trip.pk
LEFT JOIN route ON trip.route_pk = route.pk
ORDER BY distance.distance
LIMIT $2
`

type ListVehicles_GeographicParams struct {
	MaxDistance float64
	NumVehicles int32
	Base        types.Geography
	SystemPk    int64
}

type ListVehicles_GeographicRow struct {
	Pk                  int64
	ID                  pgtype.Text
	SystemPk            int64
	TripPk              pgtype.Int8
	Label               pgtype.Text
	LicensePlate        pgtype.Text
	CurrentStatus       pgtype.Text
	Bearing             pgtype.Float4
	Odometer            pgtype.Float8
	Speed               pgtype.Float4
	CongestionLevel     string
	UpdatedAt           pgtype.Timestamptz
	CurrentStopPk       pgtype.Int8
	CurrentStopSequence pgtype.Int4
	OccupancyStatus     pgtype.Text
	FeedPk              int64
	OccupancyPercentage pgtype.Int4
	Location            types.Geography
	StopID              pgtype.Text
	StopName            pgtype.Text
	TripID              pgtype.Text
	TripDirectionID     pgtype.Bool
	RouteID             pgtype.Text
	RouteColor          pgtype.Text
}

func (q *Queries) ListVehicles_Geographic(ctx context.Context, arg ListVehicles_GeographicParams) ([]ListVehicles_GeographicRow, error) {
	rows, err := q.db.Query(ctx, listVehicles_Geographic,
		arg.MaxDistance,
		arg.NumVehicles,
		arg.Base,
		arg.SystemPk,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListVehicles_GeographicRow
	for rows.Next() {
		var i ListVehicles_GeographicRow
		if err := rows.Scan(
			&i.Pk,
			&i.ID,
			&i.SystemPk,
			&i.TripPk,
			&i.Label,
			&i.LicensePlate,
			&i.CurrentStatus,
			&i.Bearing,
			&i.Odometer,
			&i.Speed,
			&i.CongestionLevel,
			&i.UpdatedAt,
			&i.CurrentStopPk,
			&i.CurrentStopSequence,
			&i.OccupancyStatus,
			&i.FeedPk,
			&i.OccupancyPercentage,
			&i.Location,
			&i.StopID,
			&i.StopName,
			&i.TripID,
			&i.TripDirectionID,
			&i.RouteID,
			&i.RouteColor,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mapTripPkToVehicleID = `-- name: MapTripPkToVehicleID :many
SELECT id, trip_pk FROM vehicle
WHERE id = ANY($1::text[])
AND system_pk = $2
`

type MapTripPkToVehicleIDParams struct {
	VehicleIds []string
	SystemPk   int64
}

type MapTripPkToVehicleIDRow struct {
	ID     pgtype.Text
	TripPk pgtype.Int8
}

func (q *Queries) MapTripPkToVehicleID(ctx context.Context, arg MapTripPkToVehicleIDParams) ([]MapTripPkToVehicleIDRow, error) {
	rows, err := q.db.Query(ctx, mapTripPkToVehicleID, arg.VehicleIds, arg.SystemPk)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MapTripPkToVehicleIDRow
	for rows.Next() {
		var i MapTripPkToVehicleIDRow
		if err := rows.Scan(&i.ID, &i.TripPk); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
